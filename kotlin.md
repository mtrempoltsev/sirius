## Kotlin

Kotlin — статически типизированный язык программирования, работающий поверх JVM и разрабатываемый компанией JetBrains. Язык назван в честь острова Котлин в Финском заливе, на котором расположен город Кронштадт.

Авторы ставили целью создать язык более лаконичный и типобезопасный, чем Java, и более простой, чем Scala. Следствием упрощения по сравнению со Scala стали также более быстрая компиляция и лучшая поддержка языка в IDE.

Язык разрабатывается с 2010 года. 15 февраля 2016 года вышел релиз 1.0, а 1 марта 2017 вышел релиз 1.1.

В мае 2017 года компания Google сообщила, что инструменты языка Kotlin, основанные на JetBrains IDE, будут по стандарту включены в Android Studio 3.0 — официальный инструмент разработки для ОС Android.

Позиционируется разработчиками как объектно-ориентированный язык, который сможет заменить Java. При этом язык полностью совместим с Java, что позволяет разработчикам постепенно перейти с Java на Kotlin. В частности, в Android язык встраивается с помощью Gradle, что позволяет для существующего Android-приложения внедрять новые функции на Kotlin без переписывания приложения целиком.

### Пакеты

Файл с исходным кодом может начинаться с объявления пакета:

```
package foo.bar

fun baz() {}

class Goo {}
```

Всё содержимое файла с исходниками (например, классы и функции) располагается в объявленном пакете. Таким образом, в приведённом выше примере полное имя функции baz() будет foo.bar.baz, а полное имя класса Goo - foo.bar.Goo.

Если файл не содержит явного объявления пакета, то его содержимое находится в безымянном "пакете по умолчанию".

#### Импорт

Помимо импорта по умолчанию каждый файл может содержать свои собственные объявления импорта. Синтаксис импорта описан а разделе Грамматика.

Мы можем импортировать одно имя, например

```
import foo.Bar // теперь Bar можно использовать без указания пакета
```

или доступное содержимое пространства имён (пакет, класс, объект и т.д.):

```
import foo.* // всё в 'foo' становится доступно без указания пакета
```

При совпадении имён мы можем разрешить коллизию используя ключевое слово as для локального переименования совпадающей сущности:

```
import foo.Bar // Bar доступен
import bar.Bar as bBar // bBar заменяет имя 'bar.Bar'
```

Ключевое слово import можно использовать не только с классами, но и с другими объявлениями:

- функции и свойства верхнего уровня;
- функции и свойства, объявленные в объявлениях объектов;
перечислениях

### Основные типы

В Kotlin всё является объектом, в том смысле, что пользователь может вызвать функцию или получить доступ к свойству любой переменной. Некоторые типы являются встроенными, т.к. их реализация оптимизирована, хотя для пользователя они могут выглядеть как обычные классы.

### Числа

Kotlin обрабатывает численные типы примерно так же, как и Java, хотя некоторые различия всё же присутствуют. Например, отсутствует неявное расширяющее преобразование для чисел, а литералы в некоторых случаях немного отличаются.

Для представления чисел в Kotlin используются следующие встроенные типы (подобные типам в Java):


| Тип | Количество бит |
| --- | --- |
| Double | 64 |
| Float | 32 |
| Long | 64 |
| Int | 32 |
| Short | 16 |
| Byte | 8 |

```
Десятичные числа: 123
Тип Long обозначается заглавной L: 123L
Шестнадцатеричные числа: 0x0F
Двоичные числа: 0b00001011
```

Также Kotlin поддерживает числа с плавающей запятой:

```
Тип Double по умолчанию: 123.5, 123.5e10
Тип Float обозначается с помощью f или F: 123.5f
```

#### Представление

Обычно платформа Java хранит числа в виде примитивных типов JVM; если же нам необходима ссылка, которая может принимать значение null (например, Int?), то используются обёртки. В приведённом ниже примере показано использование обёрток.

Обратите внимание, что использование обёрток для одного и того же числа не гарантирует равенства ссылок на них:

```
val a: Int = 10000
print(a === a) // true
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA === anotherBoxedA) // false
```

Однако, равенство по значению сохраняется:

```
val a: Int = 10000
print(a == a) // Prints 'true'
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA == anotherBoxedA) // Prints 'true'
```

#### Явные преобразования

Из-за разницы в представлениях меньшие типы не являются подтипами бОльших типов, как следствие, неявное преобразование меньших типов в большие НЕ происходит.

```
val a: Int = 1
val b: Long = a // error
```

Мы можем использовать явное преобразование для "расширения" чисел

```
val b: Long = a.toLong()
```

Каждый численный тип поддерживает следующие преобразования:

```
toByte(): Byte
toShort(): Short
toInt(): Int
toLong(): Long
toFloat(): Float
toDouble(): Double
toChar(): Char
```

Отсутствие неявного преобразования редко бросается в глаза, поскольку тип выводится из контекста, а арифметические действия перегружаются для подходящих преобразований, например:

```
val l = 1L + 3 // Long + Int => Long
```

#### Арифметические действия

Kotlin поддерживает обычный набор арифметических действий над числами.

Что касается битовых операций, то вместо особых обозначений для них используются именованные функции, которые могут быть вызваны в инфиксной форме, к примеру:

```
val x = (1 shl 2) and 0x000FF000
```

Ниже приведён полный список битовых операций (доступны только для типов Int и Long):

```
shl(bits) – сдвиг влево с учётом знака (<< в Java)
shr(bits) – сдвиг вправо с учётом знака (>> в Java)
ushr(bits) – сдвиг вправо без учёта знака (>>> в Java)
and(bits) – побитовое И
or(bits) – побитовое ИЛИ
xor(bits) – побитовое исключающее ИЛИ
inv() – побитовое отрицание
```

### Символы

Символы в Kotlin представлены типом Char. Напрямую они не могут рассматриваться в качестве чисел^


```
fun check(c: Char) {
  if (c == 1) { // error
  }
}
```

Символьные литералы записываются в одинарных кавычках: '1', '\n', '\uFF00'. Мы можем явно привести символ в число типа Int:

```
fun decimalDigitValue(c: Char): Int {
  if (c !in '0'..'9')
    throw IllegalArgumentException("Вне диапазона")
  return c.toInt() - '0'.toInt() // Явные преобразования в число
}
```

Подобно числам, символы оборачиваются при необходимости использования nullable ссылки. При использовании обёрток тождественность (равенство по ссылке) не сохраняется.

#### Логический тип

Тип Boolean представляет логический тип данных и принимает два значения: true и false.

При необходимости использования nullable ссылок логические переменные оборачиваются.

Встроенные действия над логическими переменными включают

```
|| – ленивое логическое ИЛИ
&& – ленивое логическое И
! - отрицание
```

#### Массивы

Массивы в Kotlin представлены классом Array, обладающим функциями get и set (которые обозначаются [] согласно соглашению о перегрузке операторов), и свойством size, а также несколькими полезными встроенными функциями:

```
class Array<T> private constructor() {
  val size: Int
  fun get(index: Int): T
  fun set(index: Int, value: T): Unit

  fun iterator(): Iterator<T>
  // ...
}
```

Для создания массива мы можем использовать библиотечную функцию arrayOf(), которой в качестве аргумента передаются элементы массива, т.е. выполнение arrayOf(1, 2, 3) создаёт массив [1, 2, 3]. 

Библиотечная функция arrayOfNulls() может быть использована для создания массива заданного размера, заполненного значениями null.

Также для создания массива можно использовать фабричную функцию, которая принимает размер массива и функцию, возвращающую начальное значение каждого элемента по его индексу:

```
// создаёт массив типа Array<String> со значениями ["0", "1", "4", "9", "16"]
val asc = Array(5, { i -> (i * i).toString() })
```

Как отмечено выше, оператор [] используется вместо вызовов встроенных функций get() и set().

Также в Kotlin есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: ByteArray, ShortArray, IntArray и т.д. Данные классы не наследуют класс Array, хотя и обладают тем же набором методов и свойств. У каждого из них есть соответствующая фабричная функция:

```
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
```

#### Строки

Строки в Kotlin представлены типом String. Строки являются неизменяемыми. Строки состоят из символов, которые могут быть получены по порядковому номеру: s[i]. Проход по строке выполняется циклом for:

```
for (c in str) {
  println(c)
}
```

#### Строковые литералы

В Kotlin представлены два типа строковых литералов: строки с экранированными символами и обычные строки, которые могут содержать символы новой строки и произвольный текст. Экранированная строка очень похожа на строку в Java:

```
val s = "Hello, world!\n"
```

Экранирование выполняется общепринятым способом, а именно с помощью обратной косой черты.

Обычная строка выделена тройной кавычкой ("""), не содержит экранированных символов, но может содержать символы новой строки и любые другие символы:

```
val text = """
  for (c in "foo")
    print(c)
"""
```

#### Строковые шаблоны

Строки могут содержать шаблонные выражения, т.е. участки кода, которые выполняются, а полученный результат встраивается в строку. Шаблон начинается со знака доллара ($) и состоит либо из простого имени (например, переменной):

```
val i = 10
val s = "i = $i" // evaluates to "i = 10"
```

либо из произвольного выражения в фигурных скобках:

```
val s = "abc"
val str = "$s.length is ${s.length}" // evaluates to "abc.length is 3"
```

Шаблоны поддерживаются как в обычных, так и в экранированных строках. При необходимости символ $ может быть представлен с помощью следующего синтаксиса:

```
val price = "${'$'}9.99"
```

### Функции

#### Объявление функций

В Kotlin функции объявляются с помощью ключевого слова fun

```
fun double(x: Int): Int {
}
```

#### Применение функций

При вызове функции используется традиционный подход

```
val result = double(2)
```

Для вызова вложенной функции используется знак точки

```
Sample().foo() //создаёт экземпляр класса Sample и вызывает foo
```

#### Инфиксная запись

Функции так же могут быть вызваны при помощи инфиксной записи, при условии, что:

- Они являются членом
- В них используется один параметр
- Когда они помечены ключевым словом infix

```
// Определяем выражение как Int
infix fun Int.shl(x: Int): Int {
...
}

// вызываем функцию, используя инфиксную запись

1 shl 2

// то же самое, что

1.shl(2)
```

#### Параметры

Параметры функции записываются аналогично системе обозначений в языке Pascal, имя:тип. Параметры разделены запятыми. Каждый параметр должен быть явно указан.

```
fun powerOf(number: Int, exponent: Int) {
...
}
```

#### Аргументы по умолчанию

Параметры функции могут иметь значения по умолчанию, которые используются в случае, если аргумент функции не указан при её вызове. Это позволяет снизить уровень перегруженности кода по сравнению с другими языками.

```
fun read(b: Array<Byte>, off: Int = 0, len: Int = b.size()) {
...
}
```

Значения по умолчанию указываются после типа знаком =.

#### Имена в названиях аргументов

Параметры функции могут быть названы в момент вызова функций. Это очень удобно, когда у функции большой список параметров, в том числе со значениями по умолчанию.

Рассмотрим такую функцию

```
fun reformat(str: String,
             normalizeCase: Boolean = true,
             upperCaseFirstLetter: Boolean = true,
             divideByCamelHumps: Boolean = false,
             wordSeparator: Char = ' ') {
...
}
```

мы можем вызвать её, используя аргументы по умолчанию

```
reformat(str)
```

Однако, при вызове этой функции без аргументов по умолчанию, получится что-то вроде

```
reformat(str, true, true, false, '_')
```

С названными аргументами мы можем сделать код намного более читаемым

```
reformat(str,
    normalizeCase = true,
    upperCaseFirstLetter = true,
    divideByCamelHumps = false,
    wordSeparator = '_'
)
```

Или, если нам не нужны все эти аргументы

```
reformat(str, wordSeparator = '_')
```

#### Функции с возвращаемым типом Unit

Если функция не возвращает никакого полезного значения, её возвращаемый тип - Unit. Unit - тип только с одним значением - Unit. Это возвращаемое значение не нуждается в явном указании

```
fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello ${name}")
    else
        println("Hi there!")
    // `return Unit` или `return` необязательны
}
```

Указание типа Unit в качестве возвращаемого значения тоже не является обязательным. Код, написанный выше, совершенно идентичен с

```
fun printHello(name: String?) {
    ...
}
```

#### Функции с одним выражением

Когда функция возвращает одно-единственное выражение, фигурные скобки { } могут быть опущены, и тело функции может быть описано после знака =

```
fun double(x: Int): Int = x * 2
```

Компилятор способен сам определить типа возвращаемого значения.

```
fun double(x: Int) = x * 2
```

#### Явные типы возвращаемых значений

Функции, в которых есть тело, всегда должны указывать возвращаемый ими тип данных (если в этом качестве не указан тип Unit). Kotlin не вычисляет самостоятельно тип возвращаемого значения для функций с заключённым в них блоком кода потому, что подобные функции могут иметь сложную структуру и возвращаемый тип неочевиден для читающего этот код человека (иногда даже для компилятора).

#### Нефиксированное число аргументов (Varargs)

Параметр функции (обычно для этого используется последний) может быть помечен модификатором vararg:

```
fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) // ts - это массив (Array)
        result.add(t)
    return result
}
```

это позволит указать множество значений в качестве аргументов функции:

```
val list = asList(1, 2, 3)
```

Внутри функции параметр с меткой vararg и типом T виден как массив элементов T, таким образом переменная ts в вышеуказанном примере имеет тип Array<T>.

Только один параметр может быть помечен меткой vararg. Если параметр с именем vararg не стоит на последнем месте в списке аргументов, значения для соответствующих параметров могут быть переданы с использованием named argument синтаксиса.

#### Область действия функций

В Kotlin функции могут быть объявлены в самом начале файла. Подразумевается, что вам не обязательно создавать объект какого-либо класса, чтобы воспользоваться его функцией (как в Java, C# или Scala). В дополнение к этому, функции в языке Kotlin могут быть объявлены локально, как функции-члены (ориг. "member functions") и функции-расширения ("extension functions").

#### Локальные функции

Koltin поддерживает локальные функции. Например, функции, вложенные в другие функции

```
fun dfs(graph: Graph) {
    fun dfs(current: Vertex, visited: Set<Vertex>) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v, visited)
    }

    dfs(graph.vertices[0], HashSet())
}
```

Такие локальные функции могут иметь доступ к локальным переменным внешних по отношению к ним функций (типа closure). Таким образом, в примере, приведённом выше, visited может быть локальной переменной.

```
fun dfs(graph: Graph) {
    val visited = HashSet<Vertex>()
    fun dfs(current: Vertex) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v)
    }

    dfs(graph.vertices[0])
}
```

#### Функции-элементы

Функции-элементы - это функции, объявленные внутри классов или объектов

```
class Sample() {
    fun foo() { print("Foo") }
}
```

Функции-элементы вызываются с использованием точки

Sample().foo() // создаёт инстанс класса Sample и вызвает его функцию foo

#### Функции-обобщения (Generic Functions)

Функции могут иметь обобщённые параметры, которые задаются треугольными скобками и помещаются перед именем функции

```
fun <T> singletonList(item: T): List<T> {
    // ...
}
```

#### Функции с хвостовой рекурсией

Kotlin поддерживает такой стиль функционального программирования, более известный как "хвостовая рекурсия". Это позволяет использовать циклические алгоритмы вместо рекурсивных функции, без риска переполнения стэка. Когда функция помечена модификатором tailrec и её форма отвечает требованиям компилятора, он оптимизирует рекурсию, оставляя вместо неё быстрое и эффективное решение этой задачи, основанное на циклах.

```
tailrec fun findFixPoint(x: Double = 1.0): Double =
  if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))
```

Этот код высчитывает fixpoint косинуса, который является математической константой. Он просто напросто постоянно вызывает Math.cos, начиная с 1.0 до тех пор, пока результат не изменится, приняв значение 0.7390851332151607. Получившийся код эквивалентен вот этому более традиционному стилю:

```
private fun findFixPoint(): Double {
    var x = 1.0
    while (true) {
        val y = Math.cos(x)
        if (x == y) return y
        x = y
    }
}
```

Для соответствия требованиям модификатора tailrec, функция должна вызывать сама себя в качестве последней операции, которую она предпринимает. Вы не можете использовать хвостовую рекурсию, когда существует ещё какой-то код после вызова этой самой рекурсии. Также нельзя использовать её внутри блоков try/catch/finally.

### Классы

Классы в Kotlin объявляются с помощью использования ключевого слова class:

```
class Invoice {
}
```

Объявление класса состоит из имени класса, заголовка (указания типов его параметров, первичного конструктора и т.п) и тела класса, заключённого в фигурные скобки. И заголовок, и тело класса являются необязательными составляющими: если у класса нет тела, фигурные скобки могут быть опущены.

```
class Empty
```

#### Конструкторы

Класс в Kotlin может иметь первичный конструктор (primary constructor) и один или более вторичных конструкторов (secondary constructors). Первичный конструктор является частью заголовка класса, его объявление идёт сразу после имени класса (и необязательных параметров):

```
class Person constructor(firstName: String)
```

Если у конструктора нет аннотаций и модификаторов видимости, ключевое слово constructor может быть опущено:

```
class Person(firstName: String)
```

Первичный конструктор не может содержать в себе исполняемого кода. Инициализирующий код может быть помещён в соответствующий блок (initializers blocks), который помечается словом init:

```
class Customer(name: String) {
    init {
        logger.info("Customer initialized with value ${name}")
    }
}
```

Обратите внимание, что параметры первичного конструктора могут быть использованы в инициализирующем блоке. Они также могут быть использованы при инициализации свойств в теле класса:

```
class Customer(name: String) {
    val customerKey = name.toUpperCase()
}
```

В действительности, для объявления и инициализации свойств первичного конструктора в Kotlin есть лаконичное синтаксическое решение:

```
class Person(val firstName: String, val lastName: String, var age: Int) {
  // ...
}
```

Свойства, объявленные в первичном конструкторе, могут быть изменяемые (var) и неизменяемые (val).

#### Второстепенные конструкторы

В классах также могут быть объявлены дополнительные конструкторы (secondary constructors), перед которыми используется ключевое слово constructor:

```
class Person {
    constructor(parent: Person) {
        parent.children.add(this)
    }
}
```

Если у класса есть главный (первичный) конструктор, каждый последующий конструктор должен прямо или косвенно ссылаться на первичный:

```
class Person(val name: String) {
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
```

#### Члены класса

Классы могут содержать в себе:

- Конструкторы и инициализирующие блоки
- Функции
- Свойства
- Вложенные классы
- Объявления объектов

#### Наследование

Для всех классов в языке Koltin родительским суперклассом является класс Any. Он также является родительским классом для любого класса, в котором не указан какой-либо другой родительский класс:

```
class Example // Implicitly inherits from Any
```

Класс Any не является аналогом java.lang.Object. В частности, у него нет никаких членов кроме методов: equals(), hashCode(), и toString().

Для явного объявления суперкласса мы помещаем его имя за знаком двоеточия в оглавлении класса:

```
open class Base(p: Int)

class Derived(p: Int) : Base(p)
```

Если у класса есть основной конструктор, базовый тип может (и должен) быть проинициализирован там же, с использованием параметров первичного конструктора.

Если у класса нет первичного конструктора, тогда каждый последующий второстепенный конструктор должен включать в себя инициализацию базового типа с помощью ключевого слова super или давать отсылку на другой конструктор, который это делает. Любые вторичные конструкторы могут ссылаться на разные конструкторы базового типа:

```
class MyView : View {
    constructor(ctx: Context) : super(ctx) {
    }

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) {
    }
}
```

Ключевое слово open является противоположностью слову final в Java: оно позволяет другим классам наследоваться от данного. По умолчанию, все классы в Kotlin имеют статус final.

#### Переопределение членов класса

В отличие от Java, Kotlin требует чёткой аннотации и для членов, которые могут быть переопределены, и для самого переопределения:

```
open class Base {
  open fun v() {}
  fun nv() {}
}

class Derived() : Base() {
  override fun v() {}
}
```

Для Derived.v() необходима аннотация override. В случае её отсутствия компилятор выдаст ошибку. Если у функции типа Base.nv() нет аннотации open, объявление метода с такой же сигнатурой в производном классе невозможно, с override или без. В final классе (классе без аннотации open), запрещено использование аннотации open для его членов.

Член класса, помеченный override, является сам по себе open, т.е. он может быть переопределён в производных классах. Если вы хотите запретить возможность переопределения такого члена, используйте final:

```
open class AnotherDerived() : Base() {
  final override fun v() {}
}
```

#### Правила переопределения

В Kotlin правила наследования имплементации определены следующим образом: если класс перенимает большое количество имплементаций одного и того члена от ближайших родительских классов, он должен переопределить этот член и обеспечить свою собственную имплементацию. Для того, чтобы отметить супертип (родительский класс), от которого мы унаследовали данную имплементацию, мы используем ключевое слово super. Для уточнения имя родительского супертипа используются треугольные скобки, например super<Base>:

```
open class A {
  open fun f() { print("A") }
  fun a() { print("a") }
}

interface B {
  fun f() { print("B") } // interface members are 'open' by default
  fun b() { print("b") }
}

class C() : A(), B {
  // The compiler requires f() to be overridden:
  override fun f() {
    super<A>.f() // call to A.f()
    super<B>.f() // call to B.f()
  }
}
```

Нормально наследоваться одновременно от A и B. У нас не возникнет никаких проблем с a() и b() в том случае, если C унаследует только одну имплементацию этих функций. Но для f() у нас есть две имплементации, унаследованные классом C, поэтому необходимо переопределить f() в C и обеспечить нашу собственную реализацию этого метода для устранения получившейся неоднозначности.

#### Абстрактные классы

Класс и некоторые его члены могут быть объявлены как abstract. Абстрактный член не имеет реализации в его классе. Обратите внимание, что нам не надо аннотировать абстрактный класс или функцию словом open - это подразумевается и так.

Можно переопределить не-абстрактный open член абстрактным

```
open class Base {
  open fun f() {}
}

abstract class Derived : Base() {
  override abstract fun f()
}
```

#### Объекты-помощники

В Kotlin, в отличие от Java или C#, в классах не бывает статических методов. В большинстве случаев рекомендуется использовать функции на уровне пакета 

Если вам нужно написать функцию, которая может быть использована без создания экземпляра класса, но имела бы доступ к данным внутри этого класса (к примеру, фабричный метод), вы можете написать её как член объявления объекта внутри этого класса.

Объявление объекта внутри класса может быть отмечено ключевым словом companion:

```
class MyClass {
    companion object Factory {
        fun create(): MyClass {
            return MyClass()
        }
    }
}
```

Для вызова членов такого companion объекта используется имя класса:

```
val instance = MyClass.create()
```

### Свойства и поля

#### Объявление свойств

Классы в Kotlin могут иметь свойства: изменяемые (mutable) и неизменяемые (read-only) — var и val соответственно.

```
public class Address { 
    public var street: String = ...
    public var state: String? = ...
}
```

Для того, чтобы воспользоваться свойством, мы просто обращаемся к его имени (как в Java):

```
fun copyAddress(address: Address): Address {
    val result = Address() // нет никакого слова `new`
    result.street = address.street
    return result
}
```

#### Геттеры и сеттеры

Полный синтаксис объявления свойства выглядит так:

```
var <propertyName>: <PropertyType> [= <property_initializer>]
    [<getter>]
    [<setter>]
```

Инициализатор property_initializer, геттер и сеттер можно не указывать. Также необязательно указывать тип свойства, если он может быть выведен из контекста.

```
var initialized = 1 // имеет тип Int, 
  // стандартный геттер и сеттер
```

Синтаксис объявления констант имеет два отличия от синтаксиса объявления изменяемых переменных: во-первых, объявление начинается с ключевого слова val вместо var, а во-вторых, объявление сеттера запрещено:

```
val simple: Int? // имеет тип Int, стандартный геттер, 
  // должен быть инициализирован в конструкторе

val inferredType = 1 // имеет тип Int и стандартный геттер
```

Мы можем самостоятельно описать методы доступа, как и обычные функции, прямо при объявлении свойств. Например, пользовательский геттер:

```
val isEmpty: Boolean
    get() = this.size == 0
```

Пользовательский сеттер выглядит примерно так:

```
var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value)
    }
```

По договорённости, имя параметра сеттера - value, но вы можете использовать любое другое.

Если вам нужно изменить область видимости метода доступа, при этом не внося изменения в реализацию по умолчанию, вы можете объявить метод доступа без объявления его тела:

```
var setterVisibility: String = "abc"
    private set // сеттер имеет private доступ и стандартную реализацию
```

#### Backing Fields

Классы в Kotlin не могут иметь полей. Т.е. переменные, которые вы объявляете внутри класса только выглядят и ведут себя как поля из Java, хотя на самом деле являются свойствами, т.к. для них неявно реализуются методы get и set. А сама переменная, в которой находится значение свойства, называется backing field. Однако, иногда, при использовании пользовательских методов доступа, необходимо иметь доступ к backing field. Для этих целей Kotlin предоставляет автоматическое backing field, к которому можно обратиться с помощью идентификатора field:

```
var counter = 0 
    set(value) {
        if (value >= 0) field = value // значение при инициализации записывается прямиком в backing field
    }
```

Идентификатор field может быть использован только в методах доступа к свойству.

Backing field будет сгенерировано для свойства, если оно использует стандартную реализацию как минимум одного из методов доступа. Или в случае, когда пользовательский метод доступа ссылается на него через идентификатор field.

Например, в нижестоящем примере не будет никакого backing field:

```
val isEmpty: Boolean
    get() = this.size == 0
```

#### Константы времени компиляции

Свойства, значение которых известно во время компиляции, могут быть помечены как константы времени компиляции. Для этого используется модификатор const. Такие свойства должны соответствовать следующим требованиям:

- Находиться на самом высоком уровне или быть членом объекта object
- Быть проинициализированными значением типа String или значением примитивного типа
- Не иметь переопределённого геттера

```
const val ID: String = "12jk466khj"
```

#### Свойства с поздней инициализацией

Обычно, свойства, объявленные non-null типом, должны быть проинициализированы в конструкторе. Однако, довольно часто это неосуществимо. К примеру, свойства могут быть инициализированы через внедрение зависимостей, в установочном методе (ориг.: "setup method") юнит-теста или в методе onCreate в Android. В таком случае вы не можете обеспечить non-null инициализацию в конструкторе, но всё равно хотите избежать проверок на null при обращении внутри тела класса к такому свойству.

Для того, чтобы справиться с такой задачей, вы можете пометить свойство модификатором lateinit:

```
public class MyTest {
    lateinit var subject: TestSubject

    @SetUp fun setup() {
        subject = TestSubject()
    }

    @Test fun test() {
        subject.method()  // объект инициализирован, проверять на null не нужно
    }
}
```

Такой модификатор может быть использован только с var свойствами, объявленными внутри тела класса (не в главном конструкторе). И только тогда, когда свойство не имеет пользовательских геттеров и сеттеров. Тип такого свойства должен быть non-null и не должен быть примитивным.

Доступ к lateinit свойству до того, как оно проинициализировано, выбрасывает специальное исключение, которое чётко обозначает, что свойство не было определено.

### Анонимные объекты и объявление объектов

Иногда нам необходимо получить экземпляр некоторого класса с незначительной модификацией, желательно без написания нового подкласса. Java справляется с этим с помощью вложенных анонимных классов. Kotlin несколько улучшает данный подход.

#### Анонимные объекты

Для того, чтобы создать объект анонимного класса, который наследуется от какого-то типа (типов), используется конструкция:

```
window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ...
    }

    override fun mouseEntered(e: MouseEvent) {
        // ...
    }
})
```

Если у супертипа есть конструктор, то в него должны быть переданы соответсвующие параметры. Множество супертипов может быть указано после двоеточия в виде списка, заполненного через запятую:

```
open class A(x: Int) {
    public open val y: Int = x
}

interface B {...}

val ab: A = object : A(1), B {
    override val y = 15
}
```

Если всё-таки нам нужен просто объект без родительских классов, то можем указать:

```
val adHoc = object {
    var x: Int = 0
    var y: Int = 0
}

print(adHoc.x + adHoc.y)
```

Код внутри объявленного объекта может обращаться к переменным за скобками так же, как вложенные анонимные классы в Java

```
fun countClicks(window: JComponent) {
    var clickCount = 0
    var enterCount = 0

    window.addMouseListener(object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
            clickCount++
        }

        override fun mouseEntered(e: MouseEvent) {
            enterCount++
        }
    })
    // ...
}
```

### Приведение и проверка типов

#### Операторы is и !is

Мы можем проверить принадлежит ли объект к какому-либо типу во время исполнения с помощью оператора is или его отрицания !is:

```
if (obj is String) {
    print(obj.length)
}

if (obj !is String) { // то же самое, что и !(obj is String)
    print("Not a String")
}
else {
    print(obj.length)
}
```

#### Умные приведения

Во многих случаях в Kotlin вам не нужно использовать явные приведения, потому что компилятор следит за is-проверками для неизменяемых значений и вставляет приведения автоматически, там, где они нужны:

```
fun demo(x: Any) {
    if (x is String) {
        print(x.length) // x автоматически преобразовывается в String
    }
}
```

Компилятор достаточно умён для того, чтобы делать автоматические приведения в случаях, когда проверка на несоответствие типу (!is) приводит к выходу из функции:

```
if (x !is String) return
print(x.length) // x автоматически преобразовывается в String
```

или в случаях, когда приводимая переменная находится справа от оператора && или ||:

```
// x автоматически преобразовывается в String справа от `||`
if (x !is String || x.length == 0) return

// x автоматически преобразовывается в String справа от `&&`
if (x is String && x.length > 0) {
    print(x.length) // x автоматически преобразовывается в String
}
```

Такие умные приведения работают вместе с when-выражениями и циклами while:

```
when (x) {
    is Int -> print(x + 1)
    is String -> print(x.length + 1)
    is IntArray -> print(x.sum())
}
```

Заметьте, что умные приведения не работают, когда компилятор не может гарантировать, что переменная не изменится между проверкой и использованием. 

Более конкретно, умные приведения будут работать:

- с локальными val переменными - всегда;
- с val свойствами - если поле имеет модификатор доступа private или internal, или проверка происходит в том же модуле, в котором объявлено это свойство. Умные приведения неприменимы к публичным свойствам или свойствам, которые имеют переопределённые getter'ы;
- с локальными var переменными - если переменная не изменяется между проверкой и использованием и не захватывается лямбдой, которая её модифицирует;
- с var свойствами - никогда (потому что переменная может быть изменена в любое время другим кодом).

#### Оператор "небезопасного" приведения

Обычно оператор приведения выбрасывает исключение, если приведение невозможно, поэтому мы называем его небезопасным. Небезопасное приведение в Kotlin выполняется с помощью инфиксного оператора as (см. приоритеты операторов):

```
val x: String = y as String
```

Заметьте, что null не может быть приведен к String, так как String не является nullable, т.е. если y - null, код выше выбросит исключение. Чтобы соответствовать семантике приведений в Java, нам нужно указать nullable тип в правой части приведения:

```
val x: String? = y as String?
```

#### Оператор "безопасного" (nullable) приведения

Чтобы избежать исключения, вы можете использовать оператор безопасного приведения as?, который возвращает null в случае неудачи:

```
val x: String? = y as? String
```

Заметьте, что несмотря на то, что справа от as? стоит non-null тип String, результат приведения является nullable.

### Управляющие инструкции

#### Условное выражение if

В языке Kotlin ключевое слово if является выражением, т.е. оно возвращает значение. Это позволяет отказаться от тернарного оператора (условие ? условие истинно : условие ложно), поскольку выражению if вполне по силам его заменить.

```
// обычное использование 
var max = a 
if (a < b) 
  max = b 
 
// с блоком else 
var max: Int
if (a > b) 
  max = a 
else 
  max = b 
 
// в виде выражения 
val max = if (a > b) a else b
```

"Ветви" выражения if могут содержать несколько строк кода, при этом последнее выражение является значением блока:

```
val max = if (a > b) { 
    print("возвращаем a") 
    a 
  } 
  else { 
    print("возвращаем b") 
    b 
  }
```

Если вы используете конструкцию if в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки else является обязательным.

#### Условное выражение when

Ключевое слово when призвано заменить оператор switch, присутствующий в C-подобных языках. В простейшем виде его использование выглядит так:

```
when (x) {
  1 -> print("x == 1")
  2 -> print("x == 2")
  else -> { // обратите внимание на блок
    print("x is neither 1 nor 2")
  }
}
```

Выражение when последовательно сравнивает аргумент со всеми указанными значениями до удовлетворения одного из условий. when можно использовать и как выражение, и как оператор. При использовании в виде выражения значение ветки, удовлетворяющей условию, становится значением всего выражения. При использовании в виде оператора значения отдельных веток отбрасываются. (В точности как if: каждая ветвь может быть блоком и её значением является значение последнего выражения блока.)

Значение ветки else вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено. Если when используется как выражение, то ветка else является обязательной, за исключением случаев, в которых компилятор может убедиться, что ветки покрывают все возможные значения.

Если для нескольких значений выполняется одно и то же действие, то условия можно перечислять в одной ветке через запятую:

```
when (x) {
  0, 1 -> print("x == 0 or x == 1")
  else -> print("otherwise")
}
```

Помимо констант в ветках можно использовать произвольные выражения:

```
when (x) {
  parseInt(s) -> print("s encodes x")
  else -> print("s does not encode x")
}
```

Также можно проверять вхождение аргумента в интервал in или !in или его наличие в коллекции:

```
when (x) {
  in 1..10 -> print("x is in the range")
  in validNumbers -> print("x is valid")
  !in 10..20 -> print("x is outside the range")
  else -> print("none of the above")
}
```

Помимо этого Кotlin позволяет с момощью is или !is проверить тип аргумента. Обратите внимание, что благодаря умным приведениям вы можете получить доступ к методам и свойствам типа без дополнительной проверки:

```
val hasPrefix = when(x) {
  is String -> x.startsWith("prefix")
  else -> false
}
```

when удобно использовать вместо цепочки условий вида if-else if. При отстутствии аргумента условия работают как простые логические выражения, а тело ветки выполняется при его истинности:

```
when {
  x.isOdd() -> print("x is odd")
  x.isEven() -> print("x is even")
  else -> print("x is funny")
}
```

#### Циклы for

Цикл for обеспечивает перебор всех значений, поставляемых итератором. Для этого используется следующий синтаксис:

```
for (item in collection)
  print(item)
```

Телом цикла может быть блок кода:

```
for (item: Int in ints) {
  // ...
}
```

Как отмечено выше, цикл for позволяет проходить по всем элементам объекта, имеющего итератор, например:

- обладающего внутренней или внешней функцией iterator(), возвращаемый тип которой
- обладает внутренней или внешней функцией next(), и
обладает внутренней или внешней функцией hasNext(), возвращающей Boolean.

Если при проходе по массиву или списку необходим порядковый номер элемента, используйте следующий подход:

```
for (i in array.indices)
  print(array[i])
```

Также вы можете использовать библиотечную функцию withIndex:

```
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
```

#### Циклы while

Ключевые слова while и do..while работают как обычно:

```
while (x > 0) {
  x--
}

do {
  val y = retrieveData()
} while (y != null)
```

### Интервалы

Интервалы имеют оператор в виде .., который дополняется in и !in. Они применимы ко всем сравниваемым (comparable) типам, но для целочисленных примитивов есть оптимизированная реализация. Вот несколько примеров применения интервалов.

```
if (i in 1..10) { // equivalent of 1 <= i && i <= 10
    println(i)
}
```

Интервалы целочисленного типа (IntRange, LongRange, CharRange) конвертируются в аналогичные циклы for из языка Java.

```
for (i in 1..4) print(i) // prints "1234"

for (i in 4..1) print(i) // prints nothing
```

А что, если вы хотите произвести итерацию в обратном порядке? Это просто. Можете использовать функцию downTo(), определённую в стандартной библиотеке:

```
for (i in 4 downTo 1) print(i) // prints "4321"
```

А есть ли возможность производить итерацию с шагом, отличным от единицы? Разумеется. В этом вам поможет функция step():

```
for (i in 1..4 step 2) print(i) // prints "13"

for (i in 4 downTo 1 step 2) print(i) // prints "42"
```

Для создания интервала, который не включает последний элемент перебора, используйте until:

```
for (i in 1 until 10) { // i in [1, 10), 10 is excluded
     println(i)
}
```

### Операторы перехода

В Kotlin определено три оператора перехода:

- return по умолчанию производит возврат из ближайшей окружающей его функции или анонимной функции
- break завершает выполнение цикла
- continue продолжает выполнение цикла со следующего его шага, без обработки оставшегося кода текущей итерации

#### Метки операторов break и continue

Любое выражение в Kotlin может быть помечено меткой label. Метки имеют идентификатор в виде знака @. Например: метки abc@, fooBar@ являются корректными (см. грамматика). Для того, чтобы пометить выражение, мы просто ставим метку перед ним:

```
loop@ for (i in 1..100) {
  // ...
}
```

Теперь мы можем уточнить значения операторов break или continue с помощью меток:

```
loop@ for (i in 1..100) {
  for (j in 1..100) {
    if (...)
      break@loop
  }
}
```

Оператор break, отмеченный @loop, переводит выполнение кода к той его части, которая находится сразу после соответствующей метки loop@. Оператор continue продолжает цикл со следующей его итерации.

### Лямбда-выражения и анонимные функции

Лямбда-выражение, или анонимная функция, это "функциональный литерал", то есть необъявленная функция, которая немедленно используется в качестве выражения. Рассмотрим следующий пример:

```
max(strings, { a, b -> a.length < b.length })
```

Функция max является функцией высшего порядка, потому что она принимает функцию в качестве второго аргумента. Этот второй аргумент является выражением, которое в свою очередь есть функция, то есть функциональный литерал. Как функция он эквивалентен объявлению:

```
fun compare(a: String, b: String): Boolean = a.length < b.length
```

#### Функциональные типы

Чтобы функция могла принять функцию в качестве параметра, необходимо указать тип функции-параметра. Например, вышеуказанная функция max определена так:

```
fun <T> max(collection: Collection<T>, less: (T, T) -> Boolean): T? {
    var max: T? = null
    for (it in collection)
        if (max == null || less(max, it))
            max = it
    return max
}
```

Параметр less является (T, T) -> Boolean типом, то есть функцией, которая принимает два параметра типа T и возвращает Boolean: 'true', если первый параметр меньше второго.

#### Синтаксис лямбда-выражений

Полная синтаксическая форма лямбда-выражений, таких как literals of function types, может быть представлена следующим образом:

```
val sum = { x: Int, y: Int -> x + y }
```

Лямбда-выражение всегда заключено в скобки {...}, объявление параметров при таком синтаксисе происходит внутри этих скобок и может включать в себя аннотации типов (опционально), тело функции начинается после знака ->. Если тип возвращаемого значения не Unit, то в качестве возвращаемого типа принимается последнее (а возможно и единственное) выражение внутри тела лямбды.

Если мы вынесем все необязательные объявления, то, что останется, будет выглядеть следующим образом:

```
val sum: (Int, Int) -> Int = { x, y -> x + y }
```

Обычное дело, когда лямбда-выражение имеет только один параметр. Если Kotlin может определить сигнатуру метода сам, он позволит нам не объявлять этот единственный параметр, и объявит его сам под именем it:

```
ints.filter { it > 0 } //Эта константа имеет тип '(it: Int) -> Boolean'
```

#### Замыкания
Лямбда-выражение имеет доступ к своему замыканию, то есть к переменным, объявленным вне этого выражения или функции. В отличае от Java, переменные, захваченные в замыкании, могут быть изменены.

### Идиомы

#### Создание DTO (он же POJO или POCO)

```
data class Customer(val name: String, val email: String)
```

создаёт класс Customer, обладающий следующими возможностями:

- геттеры (и сеттеры в случае var's) для всех свойств
- метод equals()
- метод hashCode()
- метод toString()
- метод copy()

#### Фильтрация списка

```
val positives = list.filter { x -> x > 0 }
```

Или короче:

```
val positives = list.filter { it > 0 }
```

#### Форматирование строк

```
println("Name $name")
```

#### Проверка объекта на принадлежность к определённому классу

```
when (x) {
    is Foo -> ...
    is Bar -> ...
    else   -> ...
}
```

#### Итерация по карте/списку пар

```
for ((k, v) in map) {
    println("$k -> $v")
}
```

Имена переменных k и v не имеют значения

#### Использование последовательностей чисел

```
for (i in 1..100) { ... }
for (x in 2..10) { ... }
```

#### Read-only список

```
val list = listOf("a", "b", "c")
```

#### Read-only ассоциативный список (map)

```
val map = mapOf("a" to 1, "b" to 2, "c" to 3)
```

#### Обращение к ассоциативному списку

```
println(map["key"])
map["key"] = value
```

#### Ленивые свойства

```
val p: String by lazy {
    // compute the string
}
```

#### Функции, состоящие из одного выражения

```
fun theAnswer() = 42
```

Что равносильно этому:

```
fun theAnswer(): Int {
    return 42
}
```

Для сокращения кода их можно эффективно совмещать с другими идиомами. Например с when:

```
fun transform(color: String): Int = when (color) {
    "Red" -> 0
    "Green" -> 1
    "Blue" -> 2
    else -> throw IllegalArgumentException("Invalid color param value")
}
```

#### Вызов нескольких методов объекта ('with')

```
class Turtle {
    fun penDown()
    fun penUp()
    fun turn(degrees: Double)
    fun forward(pixels: Double)
}

val myTurtle = Turtle()
with(myTurtle) { //draw a 100 pix square
    penDown()
    for(i in 1..4) {
        forward(100.0)
        turn(90.0)
    }
    penUp()
}
```

### Исключения

#### Классы исключений

Все исключения в Kotlin являются наследниками класса Throwable. У каждого исключения есть сообщение, трассировка стека, а также причина, по которой это исключение вероятно было вызвано.

Для того, чтобы возбудить исключение явным образом, используйте оператор throw

```
throw MyException("Hi There!")
```

Оператор try позволяет перехватывать исключения

```
try {
    // some code
}
catch (e: SomeException) {
    // handler
}
finally {
    // optional finally block
}
```

В коде может быть любое количество блоков catch (такие блоки могут и вовсе отсутствовать). Блоки finally могут быть опущены. Однако, должен быть использован как минимум один блок catch или finally.

> Try - это выражение

Ключевое слово try является выражением, то есть оно может иметь возвращаемое значение.

```
val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
```

Возвращаемым значением будет либо последнее выражение в блоке try, либо последнее выражение в блоке catch (или блоках). Содержимое finally блока никак не повлияет на результат try-выражения.

#### Проверяемые исключения

В языке Kotlin нет проверяемых исключений.

### Соглашение о стилистике кода

#### Правила наименований

При возникновении сомнений по умолчанию используются следующие правила:

- используйте camelCase в названиях (а также избегайте подчёркиваний)
- названия типов пишутся с заглавной буквы
- названия методов и свойств начинаются со строчной буквы
- используйте отступ из 4 пробелов

#### Двоеточие

В тех случаях, когда двоеточие разделяет тип и подтип, перед двоеточием ставится пробел. Если же двоеточие ставится между сущностью и типом, то пробел опускается:

```
interface Foo<out T : Any> : Bar {
    fun foo(a: Int): T
}
```

#### Лямбда-выражения

В лямбда-выражениях фигурные скобки, а также стрелка и параметры отделяются пробелами. Желательно передавать лямбду за пределами скобок.

```
list.filter { it > 10 }.map { element -> element * 2 }
```

В коротких лямбда-выражениях, не являющихся вложенными, рекомендуется использовать соглашение it вместо явного объявления параметра. Во вложенных лямбдах с параметрами последние всегда должны быть объявлены.

#### Объявление классов

Классы с небольшим количеством аргументов можно писать на одной строчке:

```
class Person(id: Int, name: String)
```

Классы с более длинными сигнатурами должны быть отформатированны так, чтобы каждый параметр располагался с новой строки

```
class Person(
    id: Int, 
    name: String,
    surname: String
) : Human(id, name) {
    // ...
}
```

Если класс расширяет несколько интерфейсов, конструктор суперкласса (если он есть) должен располагаться на первой строке, а после него, список расширяемых интерфейсов: каждый интерфейс с новой строки.

```
class Person(
    id: Int, 
    name: String,
    surname: String
) : Human(id, name),
    KotlinMaker {
    // ...
}
```

Для параметров конструктора может использоваться как обычный отступ, так и двойной.

#### Тип Unit

Если возвращаемым типом является Unit, то его можно явно не указывать:

```
fun foo() { // здесь пропущено ": Unit"

}
```

#### Функции vs Свойства

В некоторых случаях, функции без аргументов могут быть взаимозаменяемы с неизменяемыми (read-only) свойствами. Несмотря на схожую семантику, есть некоторые стилистические соглашения, указывающие на то, когда лучше использовать одно из этих решений.

Использование свойства перед функцией предпочтительнее, когда лежащий в основе алгоритм:

- не выбрасывает исключений
- имеет O(1) сложность
- не требует больших затрат на выполнение (или результат вычислений кэшируется при первом вызове)
- возвращает одинаковый результат